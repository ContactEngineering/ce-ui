// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseURL: 'http://localhost:8000' | (string & {});
};

/**
 * * `no-access` - No Access
 * * `view` - View
 * * `edit` - Edit
 * * `full` - Full
 */
export type Allow254Enum = 'no-access' | 'view' | 'edit' | 'full';

/**
 * * `view` - Read-only access
 * * `edit` - Change the model data
 * * `full` - Grant/revoke permissions of other users
 */
export type AllowF47Enum = 'view' | 'edit' | 'full';

/**
 * * `exp` - Experimental data
 * * `sim` - Simulated data
 * * `dum` - Dummy data
 */
export type CategoryEnum = 'exp' | 'sim' | 'dum';

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type Configuration = {
    readonly valid_since: string;
    readonly versions: string;
};

/**
 * * `center` - No detrending, but subtract mean height
 * * `height` - Remove tilt
 * * `curvature` - Remove curvature and tilt
 */
export type DetrendModeEnum = 'center' | 'height' | 'curvature';

/**
 * * `draft` - only visible in Fabrica, DOI can be deleted
 * * `registered` - registered with the DOI Resolver, cannot be deleted
 * * `findable` - registered with the DOI Resolver and indexed in DataCite Search, cannot be deleted
 */
export type DoiStateEnum = 'draft' | 'registered' | 'findable';

/**
 * * `do-not-fill` - Do not fill undefined data points
 * * `harmonic` - Interpolate undefined data points with harmonic functions
 */
export type FillUndefinedDataModeEnum = 'do-not-fill' | 'harmonic';

/**
 * Serializer for granting organization access request
 */
export type GrantOrganizationRequest = {
    /**
     * Organization identifier (URL or ID) to grant access to
     */
    organization: string;
    /**
     * Permission level to grant
     *
     * * `no-access` - No Access
     * * `view` - View
     * * `edit` - Edit
     * * `full` - Full
     */
    allow: Allow254Enum;
};

/**
 * Serializer for granting user access request
 */
export type GrantUserRequest = {
    /**
     * User identifier (URL or ID) to grant access to
     */
    user: string;
    /**
     * Permission level to grant
     *
     * * `no-access` - No Access
     * * `view` - View
     * * `edit` - Edit
     * * `full` - Full
     */
    allow: Allow254Enum;
};

/**
 * * `undefined` - Instrument of unknown type - all data considered as reliable
 * * `microscope-based` - Microscope-based instrument with known resolution
 * * `contact-based` - Contact-based instrument with known tip radius
 */
export type InstrumentTypeEnum = 'undefined' | 'microscope-based' | 'contact-based';

/**
 * * `N/A` - Kind is unknown
 * * `att` - Attachment
 * * `der` - Data derived from a raw data file
 * * `raw` - Raw data file as uploaded by a user
 */
export type KindEnum = 'N/A' | 'att' | 'der' | 'raw';

/**
 * * `cc0-1.0` - CC0 1.0 (Public Domain Dedication)
 * * `ccby-4.0` - CC BY 4.0
 * * `ccbysa-4.0` - CC BY-SA 4.0
 */
export type LicenseEnum = 'cc0-1.0' | 'ccby-4.0' | 'ccbysa-4.0';

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type Manifest = {
    readonly url: string;
    readonly id: number;
    folder: string;
    readonly uploaded_by: string;
    filename: string;
    readonly file: string;
    kind: KindEnum;
    readonly created: string;
    readonly updated: string;
    readonly upload_confirmed: string;
    readonly upload_instructions: {
        method: string;
        url: string;
    };
};

export type NullEnum = unknown;

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type Organization = {
    readonly url: string;
    readonly id: number;
    readonly api: {
        users: string;
        add_user: string;
        remove_user: string;
    };
    /**
     * Name of Organization
     */
    name: string;
    /**
     * Available Plugins
     *
     * Comma-separated list of names of plugin packages
     * available for this organization.
     *
     */
    plugins_available?: string;
};

/**
 * Serializer for organization permissions
 */
export type OrganizationPermission = {
    readonly id: number;
    organization: Organization;
    allow: AllowF47Enum;
};

export type PaginatedOrganizationList = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<Organization>;
};

export type PaginatedPublicationList = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<Publication>;
};

export type PaginatedResultList = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<Result>;
};

export type PaginatedSurfaceList = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<Surface>;
};

export type PaginatedSurfaceV2List = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<SurfaceV2>;
};

export type PaginatedTagList = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<Tag>;
};

export type PaginatedTopographyList = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<Topography>;
};

export type PaginatedTopographyV2List = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<TopographyV2>;
};

export type PaginatedUserList = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<User>;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedManifest = {
    readonly url?: string;
    readonly id?: number;
    folder?: string;
    readonly uploaded_by?: string;
    filename?: string;
    readonly file?: string;
    kind?: KindEnum;
    readonly created?: string;
    readonly updated?: string;
    readonly upload_confirmed?: string;
    readonly upload_instructions?: {
        method: string;
        url: string;
    };
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedOrganization = {
    readonly url?: string;
    readonly id?: number;
    readonly api?: {
        users: string;
        add_user: string;
        remove_user: string;
    };
    /**
     * Name of Organization
     */
    name?: string;
    /**
     * Available Plugins
     *
     * Comma-separated list of names of plugin packages
     * available for this organization.
     *
     */
    plugins_available?: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedSurface = {
    readonly url?: string;
    readonly id?: number;
    readonly api?: {
        set_permissions: string;
        download: string;
        async_download: string;
    };
    readonly creator?: string;
    readonly topography_set?: Array<Topography>;
    readonly attachments?: string;
    readonly topographies?: string;
    name?: string;
    category?: CategoryEnum | NullEnum | null;
    description?: string;
    tags?: Array<string>;
    readonly creation_datetime?: string;
    readonly modification_datetime?: string;
    readonly permissions?: string;
    properties?: {
        [key: string]: never;
    };
    readonly publication?: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedSurfaceV2 = {
    readonly url?: string;
    readonly id?: number;
    readonly api?: {
        async_download: string;
        topographies: string;
    };
    readonly permissions?: {
        id: number;
        url: string;
        allow: 'view' | 'edit' | 'full';
    };
    readonly creator?: {
        id: number;
        url: string;
        name: string;
    };
    readonly owner?: {
        id?: number;
        url?: string;
    };
    readonly attachments?: {
        id?: number;
        url?: string;
    };
    name?: string;
    category?: CategoryEnum | NullEnum | null;
    description?: string;
    tags?: Array<string>;
    readonly creation_time?: string | null;
    readonly modification_time?: string | null;
    properties?: {
        [key: string]: never;
    };
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedTopography = {
    readonly url?: string;
    readonly id?: number;
    readonly api?: {
        force_inspect: string;
    };
    surface?: string;
    readonly creator?: string;
    datafile?: Manifest;
    squeezed_datafile?: Manifest;
    thumbnail?: Manifest;
    readonly attachments?: string;
    readonly deepzoom?: string;
    name?: string;
    datafile_format?: string | null;
    channel_names?: unknown;
    data_source?: number | null;
    description?: string;
    measurement_date?: string | null;
    readonly size_editable?: boolean;
    size_x?: number | null;
    size_y?: number | null;
    readonly unit_editable?: boolean;
    unit?: UnitEnum | NullEnum | null;
    readonly height_scale_editable?: boolean;
    height_scale?: number;
    has_undefined_data?: boolean | null;
    fill_undefined_data_mode?: FillUndefinedDataModeEnum;
    detrend_mode?: DetrendModeEnum;
    readonly resolution_x?: number | null;
    readonly resolution_y?: number | null;
    readonly bandwidth_lower?: number | null;
    readonly bandwidth_upper?: number | null;
    readonly short_reliability_cutoff?: number | null;
    readonly is_periodic_editable?: boolean;
    is_periodic?: boolean;
    instrument_name?: string;
    instrument_type?: InstrumentTypeEnum;
    instrument_parameters?: unknown;
    readonly is_metadata_complete?: boolean;
    readonly creation_datetime?: string;
    readonly modification_datetime?: string;
    readonly task_duration?: string;
    readonly task_error?: string;
    readonly task_progress?: number;
    readonly task_state?: string;
    tags?: Array<string>;
    readonly permissions?: {
        [key: string]: unknown;
    };
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedTopographyV2 = {
    readonly url?: string;
    readonly id?: number;
    readonly api?: {
        force_inspect: string;
    };
    readonly permissions?: {
        id: number;
        url: string;
        allow: 'view' | 'edit' | 'full';
    };
    surface?: {
        id?: number;
        url?: string;
    };
    readonly creator?: {
        id: number;
        url: string;
        name: string;
    };
    readonly datafile?: {
        id?: number;
        url?: string;
    };
    readonly squeezed_datafile?: {
        id?: number;
        url?: string;
    };
    readonly thumbnail?: {
        id?: number;
        url?: string;
    };
    readonly attachments?: {
        id?: number;
        url?: string;
    };
    readonly deepzoom?: {
        id?: number;
        url?: string;
    };
    name?: string;
    datafile_format?: string | null;
    channel_names?: unknown;
    data_source?: number | null;
    description?: string;
    measurement_date?: string | null;
    readonly size_editable?: boolean;
    size_x?: number | null;
    size_y?: number | null;
    readonly unit_editable?: boolean;
    unit?: UnitEnum | NullEnum | null;
    readonly height_scale_editable?: boolean;
    height_scale?: number;
    has_undefined_data?: boolean | null;
    fill_undefined_data_mode?: FillUndefinedDataModeEnum;
    detrend_mode?: DetrendModeEnum;
    readonly resolution_x?: number | null;
    readonly resolution_y?: number | null;
    readonly bandwidth_lower?: number | null;
    readonly bandwidth_upper?: number | null;
    readonly short_reliability_cutoff?: number | null;
    readonly is_periodic_editable?: boolean;
    is_periodic?: boolean;
    instrument_name?: string;
    instrument_type?: InstrumentTypeEnum;
    instrument_parameters?: unknown;
    readonly is_metadata_complete?: string;
    readonly creation_time?: string;
    readonly modification_time?: string | null;
    readonly task_duration?: string;
    readonly task_error?: string;
    readonly task_progress?: number;
    readonly task_state?: string;
    tags?: Array<string>;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedUser = {
    readonly url?: string;
    readonly id?: number;
    readonly api?: {
        organizations: string;
        add_organization: string;
        remove_organization: string;
    };
    /**
     * Name of User
     */
    name?: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     */
    username?: string;
    readonly orcid?: string;
    /**
     * Email address
     */
    email?: string;
    readonly date_joined?: string;
    readonly is_verified?: boolean;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedWorkflowTemplate = {
    readonly id?: number;
    name?: string;
    kwargs?: unknown;
    implementation?: string | null;
    readonly creator?: string;
};

/**
 * Serializer for permission sets
 */
export type PermissionSet = {
    readonly id: number;
    readonly url: string;
    readonly user_permissions: Array<UserPermission>;
    readonly organization_permissions: Array<OrganizationPermission>;
    readonly api: {
        grant_user_access: string;
        revoke_user_access: string;
        grant_organization_access: string;
        revoke_organization_access: string;
    };
};

export type Publication = {
    readonly url: string;
    readonly id: number;
    short_url?: string | null;
    readonly surface: string;
    readonly original_surface: string;
    publisher: User;
    publisher_orcid_id?: string;
    version?: number;
    readonly datetime: string;
    license?: LicenseEnum;
    authors_json?: unknown;
    datacite_json?: unknown;
    doi_name?: string;
    doi_state?: DoiStateEnum;
    readonly citation: string;
    readonly has_access_to_original_surface: string;
    readonly download_url: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type Result = {
    readonly url: string;
    readonly id: number;
    readonly api: {
        set_name: string;
    };
    readonly dependencies_url: string;
    readonly function: string;
    subject: Subject;
    readonly kwargs: unknown;
    readonly creation_time: string;
    readonly task_state: string;
    readonly task_progress: number;
    readonly task_messages: Array<string>;
    readonly task_memory: number | null;
    readonly task_error: string;
    readonly task_traceback: string | null;
    readonly task_submission_time: string | null;
    readonly task_start_time: string | null;
    readonly task_end_time: string | null;
    readonly task_duration: string;
    readonly task_id: string | null;
    readonly launcher_task_id: string | null;
    readonly dois: unknown;
    readonly configuration: string;
    readonly folder: string;
    readonly name: string | null;
    readonly creator: {
        id: number;
        url: string;
        name: string;
    };
};

/**
 * Serializer for revoking organization access request
 */
export type RevokeOrganizationRequest = {
    /**
     * Organization identifier (URL or ID) to revoke access from
     */
    organization: string;
};

/**
 * Serializer for revoking user access request
 */
export type RevokeUserRequest = {
    /**
     * User identifier (URL or ID) to revoke access from
     */
    user: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type Subject = {
    readonly id: number;
    readonly tag: string;
    readonly topography: string;
    readonly surface: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type Surface = {
    readonly url: string;
    readonly id: number;
    readonly api: {
        set_permissions: string;
        download: string;
        async_download: string;
    };
    readonly creator: string;
    readonly topography_set: Array<Topography>;
    readonly attachments: string;
    readonly topographies: string;
    name?: string;
    category?: CategoryEnum | NullEnum | null;
    description?: string;
    tags?: Array<string>;
    readonly creation_datetime: string;
    readonly modification_datetime: string;
    readonly permissions: string;
    properties?: {
        [key: string]: never;
    };
    readonly publication: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type SurfaceV2 = {
    readonly url: string;
    readonly id: number;
    readonly api: {
        async_download: string;
        topographies: string;
    };
    readonly permissions: {
        id: number;
        url: string;
        allow: 'view' | 'edit' | 'full';
    };
    readonly creator: {
        id: number;
        url: string;
        name: string;
    };
    readonly owner: {
        id?: number;
        url?: string;
    };
    readonly attachments: {
        id?: number;
        url?: string;
    };
    name?: string;
    category?: CategoryEnum | NullEnum | null;
    description?: string;
    tags?: Array<string>;
    readonly creation_time: string | null;
    readonly modification_time: string | null;
    properties?: {
        [key: string]: never;
    };
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type Tag = {
    readonly url: string;
    readonly api: {
        set_permissions: string;
        download: string;
        async_download: string;
    };
    readonly id: number;
    name: string;
    readonly children: string;
    path: string;
    /**
     * The name of the tag, without ancestors
     */
    label: string;
    slug: string;
    /**
     * The level of the tag in the tree
     */
    level?: number;
    /**
     * Internal counter of how many times this tag is in use
     */
    count?: number;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type Topography = {
    readonly url: string;
    readonly id: number;
    readonly api: {
        force_inspect: string;
    };
    surface: string;
    readonly creator: string;
    datafile?: Manifest;
    squeezed_datafile?: Manifest;
    thumbnail?: Manifest;
    readonly attachments: string;
    readonly deepzoom: string;
    name: string;
    datafile_format?: string | null;
    channel_names?: unknown;
    data_source?: number | null;
    description?: string;
    measurement_date?: string | null;
    readonly size_editable: boolean;
    size_x?: number | null;
    size_y?: number | null;
    readonly unit_editable: boolean;
    unit?: UnitEnum | NullEnum | null;
    readonly height_scale_editable: boolean;
    height_scale?: number;
    has_undefined_data?: boolean | null;
    fill_undefined_data_mode?: FillUndefinedDataModeEnum;
    detrend_mode?: DetrendModeEnum;
    readonly resolution_x: number | null;
    readonly resolution_y: number | null;
    readonly bandwidth_lower: number | null;
    readonly bandwidth_upper: number | null;
    readonly short_reliability_cutoff: number | null;
    readonly is_periodic_editable: boolean;
    is_periodic?: boolean;
    instrument_name?: string;
    instrument_type?: InstrumentTypeEnum;
    instrument_parameters?: unknown;
    readonly is_metadata_complete: boolean;
    readonly creation_datetime: string;
    readonly modification_datetime: string;
    readonly task_duration: string;
    readonly task_error: string;
    readonly task_progress: number;
    readonly task_state: string;
    tags?: Array<string>;
    readonly permissions: {
        [key: string]: unknown;
    };
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type TopographyV2 = {
    readonly url: string;
    readonly id: number;
    readonly api: {
        force_inspect: string;
    };
    readonly permissions: {
        id: number;
        url: string;
        allow: 'view' | 'edit' | 'full';
    };
    surface: {
        id?: number;
        url?: string;
    };
    readonly creator: {
        id: number;
        url: string;
        name: string;
    };
    readonly datafile: {
        id?: number;
        url?: string;
    };
    readonly squeezed_datafile: {
        id?: number;
        url?: string;
    };
    readonly thumbnail: {
        id?: number;
        url?: string;
    };
    readonly attachments: {
        id?: number;
        url?: string;
    };
    readonly deepzoom: {
        id?: number;
        url?: string;
    };
    name: string;
    datafile_format?: string | null;
    channel_names?: unknown;
    data_source?: number | null;
    description?: string;
    measurement_date?: string | null;
    readonly size_editable: boolean;
    size_x?: number | null;
    size_y?: number | null;
    readonly unit_editable: boolean;
    unit?: UnitEnum | NullEnum | null;
    readonly height_scale_editable: boolean;
    height_scale?: number;
    has_undefined_data?: boolean | null;
    fill_undefined_data_mode?: FillUndefinedDataModeEnum;
    detrend_mode?: DetrendModeEnum;
    readonly resolution_x: number | null;
    readonly resolution_y: number | null;
    readonly bandwidth_lower: number | null;
    readonly bandwidth_upper: number | null;
    readonly short_reliability_cutoff: number | null;
    readonly is_periodic_editable: boolean;
    is_periodic?: boolean;
    instrument_name?: string;
    instrument_type?: InstrumentTypeEnum;
    instrument_parameters?: unknown;
    readonly is_metadata_complete: string;
    readonly creation_time: string;
    readonly modification_time: string | null;
    readonly task_duration: string;
    readonly task_error: string;
    readonly task_progress: number;
    readonly task_state: string;
    tags?: Array<string>;
};

/**
 * * `km` - kilometers
 * * `m` - meters
 * * `mm` - millimeters
 * * `µm` - micrometers
 * * `nm` - nanometers
 * * `Å` - angstrom
 * * `pm` - picometers
 */
export type UnitEnum = 'km' | 'm' | 'mm' | 'µm' | 'nm' | 'Å' | 'pm';

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type User = {
    readonly url: string;
    readonly id: number;
    readonly api: {
        organizations: string;
        add_organization: string;
        remove_organization: string;
    };
    /**
     * Name of User
     */
    name: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     */
    username: string;
    readonly orcid: string;
    /**
     * Email address
     */
    email?: string;
    readonly date_joined: string;
    readonly is_verified: boolean;
};

/**
 * Serializer for user permissions
 */
export type UserPermission = {
    readonly id: number;
    readonly user: {
        id: number;
        url: string;
        name: string;
    };
    allow: AllowF47Enum;
    readonly is_current_user: boolean;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type Workflow = {
    readonly id: number;
    readonly url: string;
    /**
     * Internal unique identifier
     */
    name: string;
    /**
     * Human-readable name
     */
    display_name: string;
    readonly visualization_type: string;
    readonly kwargs_schema: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type WorkflowTemplate = {
    readonly id: number;
    name: string;
    kwargs?: unknown;
    implementation: string | null;
    readonly creator: string;
};

/**
 * Serializer for ZipContainer model.
 */
export type ZipContainerV2 = {
    readonly url: string;
    readonly id: number;
    readonly api: {
        upload_finished: string;
    };
    readonly permissions: {
        id: number;
        url: string;
        allow: 'view' | 'edit' | 'full';
    };
    readonly manifest: {
        id?: number;
        url?: string;
    };
    readonly task_duration: string;
    readonly task_error: string;
    readonly task_progress: number;
    readonly task_state: string;
    task_memory?: number | null;
    task_traceback?: string | null;
    readonly celery_task_state: string;
    readonly self_reported_task_state: string;
    readonly creation_time: string;
    readonly modification_time: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type ManifestWritable = {
    folder: string;
    filename: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type OrganizationWritable = {
    /**
     * Name of Organization
     */
    name: string;
    /**
     * Available Plugins
     *
     * Comma-separated list of names of plugin packages
     * available for this organization.
     *
     */
    plugins_available?: string;
};

/**
 * Serializer for organization permissions
 */
export type OrganizationPermissionWritable = {
    allow: AllowF47Enum;
};

export type PaginatedOrganizationListWritable = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<OrganizationWritable>;
};

export type PaginatedPublicationListWritable = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<PublicationWritable>;
};

export type PaginatedResultListWritable = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<ResultWritable>;
};

export type PaginatedSurfaceListWritable = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<SurfaceWritable>;
};

export type PaginatedSurfaceV2ListWritable = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<SurfaceV2Writable>;
};

export type PaginatedTagListWritable = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<TagWritable>;
};

export type PaginatedTopographyListWritable = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<TopographyWritable>;
};

export type PaginatedTopographyV2ListWritable = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<TopographyV2Writable>;
};

export type PaginatedUserListWritable = {
    count: number;
    next?: string | null;
    previous?: string | null;
    results: Array<UserWritable>;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedManifestWritable = {
    folder?: string;
    filename?: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedOrganizationWritable = {
    /**
     * Name of Organization
     */
    name?: string;
    /**
     * Available Plugins
     *
     * Comma-separated list of names of plugin packages
     * available for this organization.
     *
     */
    plugins_available?: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedSurfaceWritable = {
    name?: string;
    category?: CategoryEnum | NullEnum | null;
    description?: string;
    tags?: Array<string>;
    properties?: {
        [key: string]: never;
    };
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedSurfaceV2Writable = {
    name?: string;
    category?: CategoryEnum | NullEnum | null;
    description?: string;
    tags?: Array<string>;
    properties?: {
        [key: string]: never;
    };
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedTopographyWritable = {
    surface?: string;
    datafile?: ManifestWritable;
    squeezed_datafile?: ManifestWritable;
    thumbnail?: ManifestWritable;
    name?: string;
    datafile_format?: string | null;
    channel_names?: unknown;
    data_source?: number | null;
    description?: string;
    measurement_date?: string | null;
    size_x?: number | null;
    size_y?: number | null;
    unit?: UnitEnum | NullEnum | null;
    height_scale?: number;
    has_undefined_data?: boolean | null;
    fill_undefined_data_mode?: FillUndefinedDataModeEnum;
    detrend_mode?: DetrendModeEnum;
    is_periodic?: boolean;
    instrument_name?: string;
    instrument_type?: InstrumentTypeEnum;
    instrument_parameters?: unknown;
    tags?: Array<string>;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedTopographyV2Writable = {
    surface?: {
        id?: number;
        url?: string;
    };
    name?: string;
    datafile_format?: string | null;
    channel_names?: unknown;
    data_source?: number | null;
    description?: string;
    measurement_date?: string | null;
    size_x?: number | null;
    size_y?: number | null;
    unit?: UnitEnum | NullEnum | null;
    height_scale?: number;
    has_undefined_data?: boolean | null;
    fill_undefined_data_mode?: FillUndefinedDataModeEnum;
    detrend_mode?: DetrendModeEnum;
    is_periodic?: boolean;
    instrument_name?: string;
    instrument_type?: InstrumentTypeEnum;
    instrument_parameters?: unknown;
    tags?: Array<string>;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedUserWritable = {
    /**
     * Name of User
     */
    name?: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     */
    username?: string;
    /**
     * Email address
     */
    email?: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type PatchedWorkflowTemplateWritable = {
    name?: string;
    kwargs?: unknown;
    implementation?: string | null;
};

/**
 * Serializer for permission sets
 */
export type PermissionSetWritable = {
    [key: string]: unknown;
};

export type PublicationWritable = {
    short_url?: string | null;
    publisher_orcid_id?: string;
    version?: number;
    license?: LicenseEnum;
    authors_json?: unknown;
    datacite_json?: unknown;
    doi_name?: string;
    doi_state?: DoiStateEnum;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type ResultWritable = {
    [key: string]: unknown;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type SurfaceWritable = {
    name?: string;
    category?: CategoryEnum | NullEnum | null;
    description?: string;
    tags?: Array<string>;
    properties?: {
        [key: string]: never;
    };
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type SurfaceV2Writable = {
    name?: string;
    category?: CategoryEnum | NullEnum | null;
    description?: string;
    tags?: Array<string>;
    properties?: {
        [key: string]: never;
    };
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type TagWritable = {
    name: string;
    path: string;
    /**
     * The name of the tag, without ancestors
     */
    label: string;
    slug: string;
    /**
     * The level of the tag in the tree
     */
    level?: number;
    /**
     * Internal counter of how many times this tag is in use
     */
    count?: number;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type TopographyWritable = {
    surface: string;
    datafile?: ManifestWritable;
    squeezed_datafile?: ManifestWritable;
    thumbnail?: ManifestWritable;
    name: string;
    datafile_format?: string | null;
    channel_names?: unknown;
    data_source?: number | null;
    description?: string;
    measurement_date?: string | null;
    size_x?: number | null;
    size_y?: number | null;
    unit?: UnitEnum | NullEnum | null;
    height_scale?: number;
    has_undefined_data?: boolean | null;
    fill_undefined_data_mode?: FillUndefinedDataModeEnum;
    detrend_mode?: DetrendModeEnum;
    is_periodic?: boolean;
    instrument_name?: string;
    instrument_type?: InstrumentTypeEnum;
    instrument_parameters?: unknown;
    tags?: Array<string>;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type TopographyV2Writable = {
    surface: {
        id?: number;
        url?: string;
    };
    name: string;
    datafile_format?: string | null;
    channel_names?: unknown;
    data_source?: number | null;
    description?: string;
    measurement_date?: string | null;
    size_x?: number | null;
    size_y?: number | null;
    unit?: UnitEnum | NullEnum | null;
    height_scale?: number;
    has_undefined_data?: boolean | null;
    fill_undefined_data_mode?: FillUndefinedDataModeEnum;
    detrend_mode?: DetrendModeEnum;
    is_periodic?: boolean;
    instrument_name?: string;
    instrument_type?: InstrumentTypeEnum;
    instrument_parameters?: unknown;
    tags?: Array<string>;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type UserWritable = {
    /**
     * Name of User
     */
    name: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     */
    username: string;
    /**
     * Email address
     */
    email?: string;
};

/**
 * Serializer for user permissions
 */
export type UserPermissionWritable = {
    allow: AllowF47Enum;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type WorkflowWritable = {
    /**
     * Internal unique identifier
     */
    name: string;
    /**
     * Human-readable name
     */
    display_name: string;
};

/**
 * A mixin that enforces strict field validation for Django REST Framework serializers.
 *
 * This mixin provides two levels of validation:
 * 1. Ensures that only fields defined in the serializer are accepted in input data
 * 2. Prevents read-only fields from being included in input data
 *
 * By default, DRF silently ignores unknown fields and read-only fields in input data.
 * This mixin makes the API more explicit by raising validation errors when clients
 * attempt to provide invalid fields, helping catch bugs and improve API clarity.
 *
 * Usage
 * -----
 * Mix this class into your serializer before the base serializer class::
 *
 * class MySerializer(StrictFieldMixin, serializers.ModelSerializer):
 * class Meta:
 * model = MyModel
 * fields = ['id', 'name', 'description']
 * read_only_fields = ['id']
 *
 * Examples
 * --------
 * With the above serializer, these requests would raise validation errors:
 *
 * - Invalid field: ``{"name": "Test", "invalid_field": "value"}``
 * Error: ``{"invalid_field": "This field does not exist"}``
 *
 * - Read-only field: ``{"id": 123, "name": "Test"}``
 * Error: ``{"id": "This field is read only"}``
 *
 * Notes
 * -----
 * Credit: RomanKhudobei
 * Source: https://github.com/encode/django-rest-framework/issues/1655
 */
export type WorkflowTemplateWritable = {
    name: string;
    kwargs?: unknown;
    implementation: string | null;
};

/**
 * Serializer for ZipContainer model.
 */
export type ZipContainerV2Writable = {
    task_memory?: number | null;
    task_traceback?: string | null;
};

export type AnalysisApiCardSeriesRetrieveData = {
    body?: never;
    path: {
        workflow: string;
    };
    query?: never;
    url: '/analysis/api/card/series/{workflow}';
};

export type AnalysisApiCardSeriesRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type AnalysisApiConfigurationRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this configuration.
         */
        id: number;
    };
    query?: never;
    url: '/analysis/api/configuration/{id}/';
};

export type AnalysisApiConfigurationRetrieveResponses = {
    200: Configuration;
};

export type AnalysisApiConfigurationRetrieveResponse = AnalysisApiConfigurationRetrieveResponses[keyof AnalysisApiConfigurationRetrieveResponses];

export type AnalysisApiMemoryUsageRetrieveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/analysis/api/memory-usage/';
};

export type AnalysisApiMemoryUsageRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type AnalysisApiNamedResultRetrieveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/analysis/api/named-result';
};

export type AnalysisApiNamedResultRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type AnalysisApiPendingRetrieveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/analysis/api/pending';
};

export type AnalysisApiPendingRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type AnalysisApiResultListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of results to return per page.
         */
        limit?: number;
        /**
         * The initial index from which to return the results.
         */
        offset?: number;
    };
    url: '/analysis/api/result/';
};

export type AnalysisApiResultListResponses = {
    200: PaginatedResultList;
};

export type AnalysisApiResultListResponse = AnalysisApiResultListResponses[keyof AnalysisApiResultListResponses];

export type AnalysisApiResultDestroyData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this workflow result.
         */
        id: number;
    };
    query?: never;
    url: '/analysis/api/result/{id}/';
};

export type AnalysisApiResultDestroyResponses = {
    /**
     * No response body
     */
    204: void;
};

export type AnalysisApiResultDestroyResponse = AnalysisApiResultDestroyResponses[keyof AnalysisApiResultDestroyResponses];

export type AnalysisApiResultRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this workflow result.
         */
        id: number;
    };
    query?: never;
    url: '/analysis/api/result/{id}/';
};

export type AnalysisApiResultRetrieveResponses = {
    200: Result;
};

export type AnalysisApiResultRetrieveResponse = AnalysisApiResultRetrieveResponses[keyof AnalysisApiResultRetrieveResponses];

export type AnalysisApiResultUpdateData = {
    body?: ResultWritable;
    path: {
        /**
         * A unique integer value identifying this workflow result.
         */
        id: number;
    };
    query?: never;
    url: '/analysis/api/result/{id}/';
};

export type AnalysisApiResultUpdateResponses = {
    200: Result;
};

export type AnalysisApiResultUpdateResponse = AnalysisApiResultUpdateResponses[keyof AnalysisApiResultUpdateResponses];

export type AnalysisApiResultDependenciesRetrieveData = {
    body?: never;
    path: {
        workflow_id: number;
    };
    query?: never;
    url: '/analysis/api/result/{workflow_id}/dependencies';
};

export type AnalysisApiResultDependenciesRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type AnalysisApiResultSetNameCreateData = {
    body?: never;
    path: {
        workflow_id: number;
    };
    query?: never;
    url: '/analysis/api/result/{workflow_id}/set-name';
};

export type AnalysisApiResultSetNameCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type AnalysisApiSetResultPermissionsPartialUpdateData = {
    body?: never;
    path: {
        workflow_id: number;
    };
    query?: never;
    url: '/analysis/api/set-result-permissions/{workflow_id}';
};

export type AnalysisApiSetResultPermissionsPartialUpdateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type AnalysisApiStatisticsRetrieveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/analysis/api/statistics/';
};

export type AnalysisApiStatisticsRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type AnalysisApiTemplateListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/analysis/api/template/';
};

export type AnalysisApiTemplateListResponses = {
    200: Array<WorkflowTemplate>;
};

export type AnalysisApiTemplateListResponse = AnalysisApiTemplateListResponses[keyof AnalysisApiTemplateListResponses];

export type AnalysisApiTemplateCreateData = {
    body: WorkflowTemplateWritable;
    path?: never;
    query?: never;
    url: '/analysis/api/template/';
};

export type AnalysisApiTemplateCreateResponses = {
    201: WorkflowTemplate;
};

export type AnalysisApiTemplateCreateResponse = AnalysisApiTemplateCreateResponses[keyof AnalysisApiTemplateCreateResponses];

export type AnalysisApiTemplateDestroyData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this workflow template.
         */
        id: number;
    };
    query?: never;
    url: '/analysis/api/template/{id}/';
};

export type AnalysisApiTemplateDestroyResponses = {
    /**
     * No response body
     */
    204: void;
};

export type AnalysisApiTemplateDestroyResponse = AnalysisApiTemplateDestroyResponses[keyof AnalysisApiTemplateDestroyResponses];

export type AnalysisApiTemplateRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this workflow template.
         */
        id: number;
    };
    query?: never;
    url: '/analysis/api/template/{id}/';
};

export type AnalysisApiTemplateRetrieveResponses = {
    200: WorkflowTemplate;
};

export type AnalysisApiTemplateRetrieveResponse = AnalysisApiTemplateRetrieveResponses[keyof AnalysisApiTemplateRetrieveResponses];

export type AnalysisApiTemplatePartialUpdateData = {
    body?: PatchedWorkflowTemplateWritable;
    path: {
        /**
         * A unique integer value identifying this workflow template.
         */
        id: number;
    };
    query?: never;
    url: '/analysis/api/template/{id}/';
};

export type AnalysisApiTemplatePartialUpdateResponses = {
    200: WorkflowTemplate;
};

export type AnalysisApiTemplatePartialUpdateResponse = AnalysisApiTemplatePartialUpdateResponses[keyof AnalysisApiTemplatePartialUpdateResponses];

export type AnalysisApiTemplateUpdateData = {
    body: WorkflowTemplateWritable;
    path: {
        /**
         * A unique integer value identifying this workflow template.
         */
        id: number;
    };
    query?: never;
    url: '/analysis/api/template/{id}/';
};

export type AnalysisApiTemplateUpdateResponses = {
    200: WorkflowTemplate;
};

export type AnalysisApiTemplateUpdateResponse = AnalysisApiTemplateUpdateResponses[keyof AnalysisApiTemplateUpdateResponses];

export type AnalysisApiWorkflowListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/analysis/api/workflow/';
};

export type AnalysisApiWorkflowListResponses = {
    200: Array<Workflow>;
};

export type AnalysisApiWorkflowListResponse = AnalysisApiWorkflowListResponses[keyof AnalysisApiWorkflowListResponses];

export type AnalysisApiWorkflowRetrieveData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/analysis/api/workflow/{name}/';
};

export type AnalysisApiWorkflowRetrieveResponses = {
    200: Workflow;
};

export type AnalysisApiWorkflowRetrieveResponse = AnalysisApiWorkflowRetrieveResponses[keyof AnalysisApiWorkflowRetrieveResponses];

export type AnalysisDownloadRetrieveData = {
    body?: never;
    path: {
        file_format: string;
        ids: string;
    };
    query?: never;
    url: '/analysis/download/{ids}/{file_format}';
};

export type AnalysisDownloadRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type AuthorizationV2GrantOrganizationAccessCreateData = {
    body: GrantOrganizationRequest;
    path: {
        /**
         * Permission set ID
         */
        id: number;
    };
    query?: never;
    url: '/authorization/v2/grant-organization-access/{id}/';
};

export type AuthorizationV2GrantOrganizationAccessCreateResponses = {
    201: OrganizationPermission;
};

export type AuthorizationV2GrantOrganizationAccessCreateResponse = AuthorizationV2GrantOrganizationAccessCreateResponses[keyof AuthorizationV2GrantOrganizationAccessCreateResponses];

export type AuthorizationV2GrantUserAccessCreateData = {
    body: GrantUserRequest;
    path: {
        /**
         * Permission set ID
         */
        id: number;
    };
    query?: never;
    url: '/authorization/v2/grant-user-access/{id}/';
};

export type AuthorizationV2GrantUserAccessCreateResponses = {
    201: UserPermission;
};

export type AuthorizationV2GrantUserAccessCreateResponse = AuthorizationV2GrantUserAccessCreateResponses[keyof AuthorizationV2GrantUserAccessCreateResponses];

export type AuthorizationV2PermissionSetRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this permission set.
         */
        id: number;
    };
    query?: never;
    url: '/authorization/v2/permission-set/{id}/';
};

export type AuthorizationV2PermissionSetRetrieveResponses = {
    200: PermissionSet;
};

export type AuthorizationV2PermissionSetRetrieveResponse = AuthorizationV2PermissionSetRetrieveResponses[keyof AuthorizationV2PermissionSetRetrieveResponses];

export type AuthorizationV2RevokeOrganizationAccessCreateData = {
    body: RevokeOrganizationRequest;
    path: {
        /**
         * Permission set ID
         */
        id: number;
    };
    query?: never;
    url: '/authorization/v2/revoke-organization-access/{id}/';
};

export type AuthorizationV2RevokeOrganizationAccessCreateResponses = {
    /**
     * No response body
     */
    204: void;
};

export type AuthorizationV2RevokeOrganizationAccessCreateResponse = AuthorizationV2RevokeOrganizationAccessCreateResponses[keyof AuthorizationV2RevokeOrganizationAccessCreateResponses];

export type AuthorizationV2RevokeUserAccessCreateData = {
    body: RevokeUserRequest;
    path: {
        /**
         * Permission set ID
         */
        id: number;
    };
    query?: never;
    url: '/authorization/v2/revoke-user-access/{id}/';
};

export type AuthorizationV2RevokeUserAccessCreateResponses = {
    /**
     * No response body
     */
    204: void;
};

export type AuthorizationV2RevokeUserAccessCreateResponse = AuthorizationV2RevokeUserAccessCreateResponses[keyof AuthorizationV2RevokeUserAccessCreateResponses];

export type EntryPointsRetrieveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/entry-points/';
};

export type EntryPointsRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type FilesFolderRetrieveData = {
    body?: never;
    path: {
        id: number;
    };
    query?: never;
    url: '/files/folder/{id}/';
};

export type FilesFolderRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type FilesManifestCreateData = {
    body: ManifestWritable;
    path?: never;
    query?: never;
    url: '/files/manifest/';
};

export type FilesManifestCreateResponses = {
    201: Manifest;
};

export type FilesManifestCreateResponse = FilesManifestCreateResponses[keyof FilesManifestCreateResponses];

export type FilesManifestDestroyData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this manifest.
         */
        id: number;
    };
    query?: never;
    url: '/files/manifest/{id}/';
};

export type FilesManifestDestroyResponses = {
    /**
     * No response body
     */
    204: void;
};

export type FilesManifestDestroyResponse = FilesManifestDestroyResponses[keyof FilesManifestDestroyResponses];

export type FilesManifestRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this manifest.
         */
        id: number;
    };
    query?: never;
    url: '/files/manifest/{id}/';
};

export type FilesManifestRetrieveResponses = {
    200: Manifest;
};

export type FilesManifestRetrieveResponse = FilesManifestRetrieveResponses[keyof FilesManifestRetrieveResponses];

export type FilesManifestPartialUpdateData = {
    body?: PatchedManifestWritable;
    path: {
        /**
         * A unique integer value identifying this manifest.
         */
        id: number;
    };
    query?: never;
    url: '/files/manifest/{id}/';
};

export type FilesManifestPartialUpdateResponses = {
    200: Manifest;
};

export type FilesManifestPartialUpdateResponse = FilesManifestPartialUpdateResponses[keyof FilesManifestPartialUpdateResponses];

export type FilesManifestUpdateData = {
    body: ManifestWritable;
    path: {
        /**
         * A unique integer value identifying this manifest.
         */
        id: number;
    };
    query?: never;
    url: '/files/manifest/{id}/';
};

export type FilesManifestUpdateResponses = {
    200: Manifest;
};

export type FilesManifestUpdateResponse = FilesManifestUpdateResponses[keyof FilesManifestUpdateResponses];

export type GoPublicationListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of results to return per page.
         */
        limit?: number;
        /**
         * The initial index from which to return the results.
         */
        offset?: number;
    };
    url: '/go/publication/';
};

export type GoPublicationListResponses = {
    200: PaginatedPublicationList;
};

export type GoPublicationListResponse = GoPublicationListResponses[keyof GoPublicationListResponses];

export type GoPublicationRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this publication.
         */
        id: number;
    };
    query?: never;
    url: '/go/publication/{id}/';
};

export type GoPublicationRetrieveResponses = {
    200: Publication;
};

export type GoPublicationRetrieveResponse = GoPublicationRetrieveResponses[keyof GoPublicationRetrieveResponses];

export type GoPublishCreateData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/go/publish/';
};

export type GoPublishCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiDownloadTagRetrieveData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/manager/api/download-tag/{name}/';
};

export type ManagerApiDownloadTagRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiImportSurfaceCreateData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/manager/api/import-surface/';
};

export type ManagerApiImportSurfaceCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiMemoryUsageRetrieveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/manager/api/memory-usage/';
};

export type ManagerApiMemoryUsageRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiPropertiesInTagCategoricalRetrieveData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/manager/api/properties-in-tag/categorical/{name}';
};

export type ManagerApiPropertiesInTagCategoricalRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiPropertiesInTagNumericalRetrieveData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/manager/api/properties-in-tag/numerical/{name}';
};

export type ManagerApiPropertiesInTagNumericalRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiSetTagPermissionsPartialUpdateData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/manager/api/set-tag-permissions/{name}';
};

export type ManagerApiSetTagPermissionsPartialUpdateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiStatisticsRetrieveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/manager/api/statistics/';
};

export type ManagerApiStatisticsRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiSurfaceListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of results to return per page.
         */
        limit?: number;
        /**
         * The initial index from which to return the results.
         */
        offset?: number;
    };
    url: '/manager/api/surface/';
};

export type ManagerApiSurfaceListResponses = {
    200: PaginatedSurfaceList;
};

export type ManagerApiSurfaceListResponse = ManagerApiSurfaceListResponses[keyof ManagerApiSurfaceListResponses];

export type ManagerApiSurfaceCreateData = {
    body?: SurfaceWritable;
    path?: never;
    query?: never;
    url: '/manager/api/surface/';
};

export type ManagerApiSurfaceCreateResponses = {
    201: Surface;
};

export type ManagerApiSurfaceCreateResponse = ManagerApiSurfaceCreateResponses[keyof ManagerApiSurfaceCreateResponses];

export type ManagerApiSurfaceDestroyData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this surface.
         */
        id: number;
    };
    query?: never;
    url: '/manager/api/surface/{id}/';
};

export type ManagerApiSurfaceDestroyResponses = {
    /**
     * No response body
     */
    204: void;
};

export type ManagerApiSurfaceDestroyResponse = ManagerApiSurfaceDestroyResponses[keyof ManagerApiSurfaceDestroyResponses];

export type ManagerApiSurfaceRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this surface.
         */
        id: number;
    };
    query?: never;
    url: '/manager/api/surface/{id}/';
};

export type ManagerApiSurfaceRetrieveResponses = {
    200: Surface;
};

export type ManagerApiSurfaceRetrieveResponse = ManagerApiSurfaceRetrieveResponses[keyof ManagerApiSurfaceRetrieveResponses];

export type ManagerApiSurfacePartialUpdateData = {
    body?: PatchedSurfaceWritable;
    path: {
        /**
         * A unique integer value identifying this surface.
         */
        id: number;
    };
    query?: never;
    url: '/manager/api/surface/{id}/';
};

export type ManagerApiSurfacePartialUpdateResponses = {
    200: Surface;
};

export type ManagerApiSurfacePartialUpdateResponse = ManagerApiSurfacePartialUpdateResponses[keyof ManagerApiSurfacePartialUpdateResponses];

export type ManagerApiSurfaceUpdateData = {
    body?: SurfaceWritable;
    path: {
        /**
         * A unique integer value identifying this surface.
         */
        id: number;
    };
    query?: never;
    url: '/manager/api/surface/{id}/';
};

export type ManagerApiSurfaceUpdateResponses = {
    200: Surface;
};

export type ManagerApiSurfaceUpdateResponse = ManagerApiSurfaceUpdateResponses[keyof ManagerApiSurfaceUpdateResponses];

export type ManagerApiSurfaceSetPermissionsPartialUpdateData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/manager/api/surface/{id}/set-permissions/';
};

export type ManagerApiSurfaceSetPermissionsPartialUpdateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiSurfaceDownloadRetrieveData = {
    body?: never;
    path: {
        surface_ids: string;
    };
    query?: never;
    url: '/manager/api/surface/{surface_ids}/download/';
};

export type ManagerApiSurfaceDownloadRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiTagListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of results to return per page.
         */
        limit?: number;
        /**
         * The initial index from which to return the results.
         */
        offset?: number;
    };
    url: '/manager/api/tag/';
};

export type ManagerApiTagListResponses = {
    200: PaginatedTagList;
};

export type ManagerApiTagListResponse = ManagerApiTagListResponses[keyof ManagerApiTagListResponses];

export type ManagerApiTagRetrieveData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/manager/api/tag/{name}/';
};

export type ManagerApiTagRetrieveResponses = {
    200: Tag;
};

export type ManagerApiTagRetrieveResponse = ManagerApiTagRetrieveResponses[keyof ManagerApiTagRetrieveResponses];

export type ManagerApiTopographyListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of results to return per page.
         */
        limit?: number;
        /**
         * The initial index from which to return the results.
         */
        offset?: number;
    };
    url: '/manager/api/topography/';
};

export type ManagerApiTopographyListResponses = {
    200: PaginatedTopographyList;
};

export type ManagerApiTopographyListResponse = ManagerApiTopographyListResponses[keyof ManagerApiTopographyListResponses];

export type ManagerApiTopographyCreateData = {
    body: TopographyWritable;
    path?: never;
    query?: never;
    url: '/manager/api/topography/';
};

export type ManagerApiTopographyCreateResponses = {
    201: Topography;
};

export type ManagerApiTopographyCreateResponse = ManagerApiTopographyCreateResponses[keyof ManagerApiTopographyCreateResponses];

export type ManagerApiTopographyDestroyData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this measurement.
         */
        id: number;
    };
    query?: never;
    url: '/manager/api/topography/{id}/';
};

export type ManagerApiTopographyDestroyResponses = {
    /**
     * No response body
     */
    204: void;
};

export type ManagerApiTopographyDestroyResponse = ManagerApiTopographyDestroyResponses[keyof ManagerApiTopographyDestroyResponses];

export type ManagerApiTopographyRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this measurement.
         */
        id: number;
    };
    query?: never;
    url: '/manager/api/topography/{id}/';
};

export type ManagerApiTopographyRetrieveResponses = {
    200: Topography;
};

export type ManagerApiTopographyRetrieveResponse = ManagerApiTopographyRetrieveResponses[keyof ManagerApiTopographyRetrieveResponses];

export type ManagerApiTopographyPartialUpdateData = {
    body?: PatchedTopographyWritable;
    path: {
        /**
         * A unique integer value identifying this measurement.
         */
        id: number;
    };
    query?: never;
    url: '/manager/api/topography/{id}/';
};

export type ManagerApiTopographyPartialUpdateResponses = {
    200: Topography;
};

export type ManagerApiTopographyPartialUpdateResponse = ManagerApiTopographyPartialUpdateResponses[keyof ManagerApiTopographyPartialUpdateResponses];

export type ManagerApiTopographyUpdateData = {
    body: TopographyWritable;
    path: {
        /**
         * A unique integer value identifying this measurement.
         */
        id: number;
    };
    query?: never;
    url: '/manager/api/topography/{id}/';
};

export type ManagerApiTopographyUpdateResponses = {
    200: Topography;
};

export type ManagerApiTopographyUpdateResponse = ManagerApiTopographyUpdateResponses[keyof ManagerApiTopographyUpdateResponses];

export type ManagerApiTopographyForceInspectCreateData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/manager/api/topography/{id}/force-inspect/';
};

export type ManagerApiTopographyForceInspectCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerApiVersionsRetrieveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/manager/api/versions/';
};

export type ManagerApiVersionsRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerV2DownloadSurfaceCreateData = {
    body?: never;
    path: {
        surface_ids: string;
    };
    query?: never;
    url: '/manager/v2/download-surface/{surface_ids}/';
};

export type ManagerV2DownloadSurfaceCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerV2DownloadTagCreateData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/manager/v2/download-tag/{name}/';
};

export type ManagerV2DownloadTagCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerV2SurfaceListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of results to return per page.
         */
        limit?: number;
        /**
         * The initial index from which to return the results.
         */
        offset?: number;
    };
    url: '/manager/v2/surface/';
};

export type ManagerV2SurfaceListResponses = {
    200: PaginatedSurfaceV2List;
};

export type ManagerV2SurfaceListResponse = ManagerV2SurfaceListResponses[keyof ManagerV2SurfaceListResponses];

export type ManagerV2SurfaceCreateData = {
    body?: SurfaceV2Writable;
    path?: never;
    query?: never;
    url: '/manager/v2/surface/';
};

export type ManagerV2SurfaceCreateResponses = {
    201: SurfaceV2;
};

export type ManagerV2SurfaceCreateResponse = ManagerV2SurfaceCreateResponses[keyof ManagerV2SurfaceCreateResponses];

export type ManagerV2SurfaceDestroyData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this surface.
         */
        id: number;
    };
    query?: never;
    url: '/manager/v2/surface/{id}/';
};

export type ManagerV2SurfaceDestroyResponses = {
    /**
     * No response body
     */
    204: void;
};

export type ManagerV2SurfaceDestroyResponse = ManagerV2SurfaceDestroyResponses[keyof ManagerV2SurfaceDestroyResponses];

export type ManagerV2SurfaceRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this surface.
         */
        id: number;
    };
    query?: never;
    url: '/manager/v2/surface/{id}/';
};

export type ManagerV2SurfaceRetrieveResponses = {
    200: SurfaceV2;
};

export type ManagerV2SurfaceRetrieveResponse = ManagerV2SurfaceRetrieveResponses[keyof ManagerV2SurfaceRetrieveResponses];

export type ManagerV2SurfacePartialUpdateData = {
    body?: PatchedSurfaceV2Writable;
    path: {
        /**
         * A unique integer value identifying this surface.
         */
        id: number;
    };
    query?: never;
    url: '/manager/v2/surface/{id}/';
};

export type ManagerV2SurfacePartialUpdateResponses = {
    200: SurfaceV2;
};

export type ManagerV2SurfacePartialUpdateResponse = ManagerV2SurfacePartialUpdateResponses[keyof ManagerV2SurfacePartialUpdateResponses];

export type ManagerV2SurfaceUpdateData = {
    body?: SurfaceV2Writable;
    path: {
        /**
         * A unique integer value identifying this surface.
         */
        id: number;
    };
    query?: never;
    url: '/manager/v2/surface/{id}/';
};

export type ManagerV2SurfaceUpdateResponses = {
    200: SurfaceV2;
};

export type ManagerV2SurfaceUpdateResponse = ManagerV2SurfaceUpdateResponses[keyof ManagerV2SurfaceUpdateResponses];

export type ManagerV2TopographyListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of results to return per page.
         */
        limit?: number;
        /**
         * The initial index from which to return the results.
         */
        offset?: number;
        /**
         * Filter topographies by surface ID
         */
        surface?: number;
        /**
         * Filter topographies by tag
         */
        tag?: string;
        /**
         * Filter topographies by tag prefix
         */
        tag_startswith?: string;
    };
    url: '/manager/v2/topography/';
};

export type ManagerV2TopographyListResponses = {
    200: PaginatedTopographyV2List;
};

export type ManagerV2TopographyListResponse = ManagerV2TopographyListResponses[keyof ManagerV2TopographyListResponses];

export type ManagerV2TopographyCreateData = {
    body: TopographyV2Writable;
    path?: never;
    query?: never;
    url: '/manager/v2/topography/';
};

export type ManagerV2TopographyCreateResponses = {
    201: TopographyV2;
};

export type ManagerV2TopographyCreateResponse = ManagerV2TopographyCreateResponses[keyof ManagerV2TopographyCreateResponses];

export type ManagerV2TopographyDestroyData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this measurement.
         */
        id: number;
    };
    query?: never;
    url: '/manager/v2/topography/{id}/';
};

export type ManagerV2TopographyDestroyResponses = {
    /**
     * No response body
     */
    204: void;
};

export type ManagerV2TopographyDestroyResponse = ManagerV2TopographyDestroyResponses[keyof ManagerV2TopographyDestroyResponses];

export type ManagerV2TopographyRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this measurement.
         */
        id: number;
    };
    query?: never;
    url: '/manager/v2/topography/{id}/';
};

export type ManagerV2TopographyRetrieveResponses = {
    200: TopographyV2;
};

export type ManagerV2TopographyRetrieveResponse = ManagerV2TopographyRetrieveResponses[keyof ManagerV2TopographyRetrieveResponses];

export type ManagerV2TopographyPartialUpdateData = {
    body?: PatchedTopographyV2Writable;
    path: {
        /**
         * A unique integer value identifying this measurement.
         */
        id: number;
    };
    query?: never;
    url: '/manager/v2/topography/{id}/';
};

export type ManagerV2TopographyPartialUpdateResponses = {
    200: TopographyV2;
};

export type ManagerV2TopographyPartialUpdateResponse = ManagerV2TopographyPartialUpdateResponses[keyof ManagerV2TopographyPartialUpdateResponses];

export type ManagerV2TopographyUpdateData = {
    body: TopographyV2Writable;
    path: {
        /**
         * A unique integer value identifying this measurement.
         */
        id: number;
    };
    query?: never;
    url: '/manager/v2/topography/{id}/';
};

export type ManagerV2TopographyUpdateResponses = {
    200: TopographyV2;
};

export type ManagerV2TopographyUpdateResponse = ManagerV2TopographyUpdateResponses[keyof ManagerV2TopographyUpdateResponses];

export type ManagerV2UploadZipFinishCreateData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/manager/v2/upload-zip/finish/{id}/';
};

export type ManagerV2UploadZipFinishCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type ManagerV2UploadZipStartCreateData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/manager/v2/upload-zip/start/';
};

export type ManagerV2UploadZipStartCreateResponses = {
    200: ZipContainerV2;
};

export type ManagerV2UploadZipStartCreateResponse = ManagerV2UploadZipStartCreateResponses[keyof ManagerV2UploadZipStartCreateResponses];

export type ManagerV2ZipContainerRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this zip container.
         */
        id: number;
    };
    query?: never;
    url: '/manager/v2/zip-container/{id}/';
};

export type ManagerV2ZipContainerRetrieveResponses = {
    200: ZipContainerV2;
};

export type ManagerV2ZipContainerRetrieveResponse = ManagerV2ZipContainerRetrieveResponses[keyof ManagerV2ZipContainerRetrieveResponses];

export type OrganizationsV1AddUserCreateData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/organizations/v1/add-user/{id}/';
};

export type OrganizationsV1AddUserCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type OrganizationsV1OrganizationListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of results to return per page.
         */
        limit?: number;
        /**
         * The initial index from which to return the results.
         */
        offset?: number;
    };
    url: '/organizations/v1/organization/';
};

export type OrganizationsV1OrganizationListResponses = {
    200: PaginatedOrganizationList;
};

export type OrganizationsV1OrganizationListResponse = OrganizationsV1OrganizationListResponses[keyof OrganizationsV1OrganizationListResponses];

export type OrganizationsV1OrganizationCreateData = {
    body: OrganizationWritable;
    path?: never;
    query?: never;
    url: '/organizations/v1/organization/';
};

export type OrganizationsV1OrganizationCreateResponses = {
    201: Organization;
};

export type OrganizationsV1OrganizationCreateResponse = OrganizationsV1OrganizationCreateResponses[keyof OrganizationsV1OrganizationCreateResponses];

export type OrganizationsV1OrganizationDestroyData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this organization.
         */
        id: number;
    };
    query?: never;
    url: '/organizations/v1/organization/{id}/';
};

export type OrganizationsV1OrganizationDestroyResponses = {
    /**
     * No response body
     */
    204: void;
};

export type OrganizationsV1OrganizationDestroyResponse = OrganizationsV1OrganizationDestroyResponses[keyof OrganizationsV1OrganizationDestroyResponses];

export type OrganizationsV1OrganizationRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this organization.
         */
        id: number;
    };
    query?: never;
    url: '/organizations/v1/organization/{id}/';
};

export type OrganizationsV1OrganizationRetrieveResponses = {
    200: Organization;
};

export type OrganizationsV1OrganizationRetrieveResponse = OrganizationsV1OrganizationRetrieveResponses[keyof OrganizationsV1OrganizationRetrieveResponses];

export type OrganizationsV1OrganizationPartialUpdateData = {
    body?: PatchedOrganizationWritable;
    path: {
        /**
         * A unique integer value identifying this organization.
         */
        id: number;
    };
    query?: never;
    url: '/organizations/v1/organization/{id}/';
};

export type OrganizationsV1OrganizationPartialUpdateResponses = {
    200: Organization;
};

export type OrganizationsV1OrganizationPartialUpdateResponse = OrganizationsV1OrganizationPartialUpdateResponses[keyof OrganizationsV1OrganizationPartialUpdateResponses];

export type OrganizationsV1OrganizationUpdateData = {
    body: OrganizationWritable;
    path: {
        /**
         * A unique integer value identifying this organization.
         */
        id: number;
    };
    query?: never;
    url: '/organizations/v1/organization/{id}/';
};

export type OrganizationsV1OrganizationUpdateResponses = {
    200: Organization;
};

export type OrganizationsV1OrganizationUpdateResponse = OrganizationsV1OrganizationUpdateResponses[keyof OrganizationsV1OrganizationUpdateResponses];

export type OrganizationsV1RemoveUserCreateData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/organizations/v1/remove-user/{id}/';
};

export type OrganizationsV1RemoveUserCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type PluginsContactCardContactMechanicsRetrieveData = {
    body?: never;
    path: {
        workflow: string;
    };
    query?: never;
    url: '/plugins/contact/card/contact-mechanics/{workflow}';
};

export type PluginsContactCardContactMechanicsRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type PluginsStatisticsCardRoughnessParametersRetrieveData = {
    body?: never;
    path: {
        workflow: string;
    };
    query?: never;
    url: '/plugins/statistics/card/roughness-parameters/{workflow}';
};

export type PluginsStatisticsCardRoughnessParametersRetrieveResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type UsersV1AddOrganizationCreateData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/users/v1/add-organization/{id}/';
};

export type UsersV1AddOrganizationCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type UsersV1RemoveOrganizationCreateData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/users/v1/remove-organization/{id}/';
};

export type UsersV1RemoveOrganizationCreateResponses = {
    /**
     * No response body
     */
    200: unknown;
};

export type UsersV1UserListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of results to return per page.
         */
        limit?: number;
        /**
         * The initial index from which to return the results.
         */
        offset?: number;
    };
    url: '/users/v1/user/';
};

export type UsersV1UserListResponses = {
    200: PaginatedUserList;
};

export type UsersV1UserListResponse = UsersV1UserListResponses[keyof UsersV1UserListResponses];

export type UsersV1UserCreateData = {
    body: UserWritable;
    path?: never;
    query?: never;
    url: '/users/v1/user/';
};

export type UsersV1UserCreateResponses = {
    201: User;
};

export type UsersV1UserCreateResponse = UsersV1UserCreateResponses[keyof UsersV1UserCreateResponses];

export type UsersV1UserDestroyData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this user.
         */
        id: number;
    };
    query?: never;
    url: '/users/v1/user/{id}/';
};

export type UsersV1UserDestroyResponses = {
    /**
     * No response body
     */
    204: void;
};

export type UsersV1UserDestroyResponse = UsersV1UserDestroyResponses[keyof UsersV1UserDestroyResponses];

export type UsersV1UserRetrieveData = {
    body?: never;
    path: {
        /**
         * A unique integer value identifying this user.
         */
        id: number;
    };
    query?: never;
    url: '/users/v1/user/{id}/';
};

export type UsersV1UserRetrieveResponses = {
    200: User;
};

export type UsersV1UserRetrieveResponse = UsersV1UserRetrieveResponses[keyof UsersV1UserRetrieveResponses];

export type UsersV1UserPartialUpdateData = {
    body?: PatchedUserWritable;
    path: {
        /**
         * A unique integer value identifying this user.
         */
        id: number;
    };
    query?: never;
    url: '/users/v1/user/{id}/';
};

export type UsersV1UserPartialUpdateResponses = {
    200: User;
};

export type UsersV1UserPartialUpdateResponse = UsersV1UserPartialUpdateResponses[keyof UsersV1UserPartialUpdateResponses];

export type UsersV1UserUpdateData = {
    body: UserWritable;
    path: {
        /**
         * A unique integer value identifying this user.
         */
        id: number;
    };
    query?: never;
    url: '/users/v1/user/{id}/';
};

export type UsersV1UserUpdateResponses = {
    200: User;
};

export type UsersV1UserUpdateResponse = UsersV1UserUpdateResponses[keyof UsersV1UserUpdateResponses];
